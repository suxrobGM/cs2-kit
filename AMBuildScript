# vim: set ts=8 sts=4 sw=4 tw=99 et ft=python:
# ruff: noqa: F821
# mypy: ignore-errors
#
# CS2-Kit - Reusable C++23 library for CS2 Metamod:Source plugins
# AMBuild Script (Static Library)
# Note: 'builder' is injected at runtime by AMBuild

import os

# =============================================================================
# SDK RESOLUTION
# =============================================================================

VENDOR_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "vendor")


def resolve_vendor_path(folder):
    """Resolve path from vendor/ submodules."""
    path = os.path.join(VENDOR_DIR, folder)
    if os.path.isdir(path):
        return path
    return None


def resolve_mms_root():
    path = builder.options.mms_path or resolve_vendor_path("mmsource-2.0")
    if not path or not os.path.isdir(path):
        raise Exception(
            "Could not find Metamod:Source 2.0. "
            "Run 'git submodule update --init --recursive' first."
        )
    return os.path.abspath(os.path.normpath(path))


def resolve_hl2sdk_manifests_root():
    path = builder.options.hl2sdk_manifests or resolve_vendor_path("hl2sdk-manifests")
    if not path or not os.path.isdir(path):
        raise Exception(
            "Could not find HL2SDK manifests. "
            "Run 'git submodule update --init --recursive' first."
        )
    return os.path.abspath(os.path.normpath(path))


# Resolve paths and load SDK helpers
mms_root = resolve_mms_root()
hl2sdk_manifests_root = resolve_hl2sdk_manifests_root()
SdkHelpers = builder.Eval(
    os.path.join(hl2sdk_manifests_root, "SdkHelpers.ambuild"), {"Project": "metamod"}
)


# =============================================================================
# LIBRARY CONFIG CLASS
# =============================================================================

class LibraryConfig:
    def __init__(self):
        self.sdks = {}
        self.sdk_manifests = []
        self.sdk_targets = []
        self.binaries = []
        self.mms_root = mms_root
        self.all_targets = []
        self.target_archs = set()

        # Detect target architectures
        target_archs = builder.options.targets.split(",") if builder.options.targets else ["x86_64"]
        for arch in target_archs:
            try:
                cxx = builder.DetectCxx(target_arch=arch)
                self.target_archs.add(cxx.target.arch)
                self.all_targets.append(cxx)
            except Exception as e:
                if builder.options.targets:
                    raise
                print(f"Skipping target {arch}: {e}")

        if not self.all_targets:
            raise Exception("No suitable C/C++ compiler was found.")

    def find_sdk_path(self, sdk_name):
        dir_name = f"hl2sdk-{sdk_name}"
        if builder.options.hl2sdk_root:
            sdk_path = os.path.abspath(os.path.normpath(
                os.path.join(builder.options.hl2sdk_root, dir_name)
            ))
            if os.path.exists(sdk_path):
                return sdk_path
        return resolve_vendor_path(dir_name)

    def detect_sdks(self):
        sdk_list = [s for s in builder.options.sdks.split(",") if s]
        SdkHelpers.find_sdk_path = self.find_sdk_path
        SdkHelpers.findSdks(builder, self.all_targets, sdk_list)

        self.sdks = SdkHelpers.sdks
        self.sdk_manifests = SdkHelpers.sdk_manifests
        self.sdk_targets = SdkHelpers.sdk_targets

        for sdk_target in self.sdk_targets:
            if not sdk_target.sdk["source2"]:
                raise Exception("Only Source 2 games are supported.")

        if self.sdk_targets:
            print(f"Using HL2SDK: {self.sdk_targets[0].sdk['path']}")
        print(f"Using Metamod:Source: {self.mms_root}")

    def configure(self):
        for cxx in self.all_targets:
            if cxx.target.arch not in ["x86", "x86_64"]:
                raise Exception(f"Unknown target architecture: {cxx.target.arch}")
            self._configure_compiler(cxx)

    def _configure_compiler(self, cxx):
        if cxx.behavior == "gcc":
            self._configure_gcc(cxx)
        elif cxx.like("msvc"):
            self._configure_msvc(cxx)

        self._configure_optimization(cxx)
        self._configure_platform(cxx)

    def _configure_gcc(self, cxx):
        cxx.defines += [
            "stricmp=strcasecmp", "_stricmp=strcasecmp",
            "_snprintf=snprintf", "_vsnprintf=vsnprintf",
            "HAVE_STDINT_H", "GNUC",
        ]
        cxx.cflags += [
            "-pipe", "-fno-strict-aliasing", "-Wall",
            "-Wno-sign-compare", "-Wno-uninitialized", "-Wno-unused",
            "-Wno-switch", "-msse", "-fPIC",
        ]
        cxx.cxxflags += ["-std=c++23"]

        if cxx.version >= "gcc-4.0" or cxx.family == "clang":
            cxx.cflags += ["-fvisibility=hidden"]
            cxx.cxxflags += ["-fvisibility-inlines-hidden"]

        cxx.cxxflags += [
            "-fno-exceptions", "-fno-threadsafe-statics",
            "-Wno-non-virtual-dtor", "-Wno-overloaded-virtual",
            "-Wno-register", "-Wno-invalid-offsetof",
        ]

        if cxx.version >= "gcc-4.7" or cxx.family == "clang":
            cxx.cxxflags += ["-Wno-delete-non-virtual-dtor"]
        if cxx.family == "gcc":
            cxx.cflags += ["-mfpmath=sse"]

    def _configure_msvc(self, cxx):
        if builder.options.debug == "1":
            cxx.cflags += ["/MTd"]
            cxx.linkflags += ["/NODEFAULTLIB:libcmt"]
        else:
            cxx.cflags += ["/MT"]

        cxx.defines += [
            "_CRT_SECURE_NO_DEPRECATE", "_CRT_SECURE_NO_WARNINGS",
            "_CRT_NONSTDC_NO_DEPRECATE", "NOMINMAX",
        ]
        cxx.cflags += ["/W3", "/std:c++latest", "/EHsc"]
        cxx.cxxflags += ["/TP"]

    def _configure_optimization(self, cxx):
        if builder.options.opt == "1":
            cxx.defines += ["NDEBUG"]
            if cxx.behavior == "gcc":
                cxx.cflags += ["-O3"]
            elif cxx.behavior == "msvc":
                cxx.cflags += ["/Ox", "/Zo"]

        if builder.options.debug == "1":
            cxx.defines += ["DEBUG", "_DEBUG"]
            if cxx.behavior == "gcc":
                cxx.cflags += ["-g3"]
            elif cxx.behavior == "msvc":
                cxx.cflags += ["/Od", "/RTC1"]

    def _configure_platform(self, cxx):
        if cxx.target.platform == "linux":
            cxx.defines += ["LINUX", "_LINUX", "POSIX", "_FILE_OFFSET_BITS=64"]
        elif cxx.target.platform == "windows":
            cxx.defines += ["WIN32", "_WINDOWS"]

    def create_static_library(self, context, compiler, sdk):
        """Create a static library with SDK and Metamod includes configured."""
        binary = compiler.StaticLibrary("cs2-kit")
        cxx = binary.compiler
        mms_core = os.path.join(self.mms_root, "core")

        # Public include directory
        cxx.cxxincludes += [
            os.path.join(builder.sourcePath, "include"),
        ]

        # Metamod includes (needed for ISmmAPI, etc.)
        cxx.cxxincludes += [
            os.path.join(context.currentSourcePath),
            mms_core,
            os.path.join(mms_core, "sourcehook"),
        ]

        # nlohmann/json (submodule at vendor/nlohmann, single_include/ has the headers)
        nlohmann_include = os.path.join(builder.sourcePath, "vendor", "nlohmann", "single_include")
        if os.path.isdir(nlohmann_include):
            cxx.cxxincludes += [nlohmann_include]

        # SDK defines
        for other_sdk in self.sdk_manifests:
            cxx.defines += [f"SE_{other_sdk['define']}={other_sdk['code']}"]

        if sdk["source2"]:
            cxx.defines += ["META_IS_SOURCE2"]
            # NOTE: Do NOT add memoverride.cpp or convar.cpp here.
            # Those are link-time symbols provided by the consuming plugin binary.

        # SDK configuration (includes, libs)
        SdkHelpers.configureCxx(context, binary, sdk)

        return binary


# =============================================================================
# BUILD
# =============================================================================

Library = LibraryConfig()
Library.detect_sdks()
Library.configure()

builder.Build(["src/AMBuilder"], {"Library": Library})
